"use strict";
var path = require("path");
var temp = require("temp");
var os_1 = require("os");
var constants_1 = require("../constants");
var constants_2 = require("../constants");
var helpers_1 = require("../common/helpers");
var ITMSTransporterService = (function () {
    function ITMSTransporterService($bplistParser, $childProcess, $errors, $fs, $hostInfo, $httpClient, $injector, $logger, $xcodeSelectService) {
        this.$bplistParser = $bplistParser;
        this.$childProcess = $childProcess;
        this.$errors = $errors;
        this.$fs = $fs;
        this.$hostInfo = $hostInfo;
        this.$httpClient = $httpClient;
        this.$injector = $injector;
        this.$logger = $logger;
        this.$xcodeSelectService = $xcodeSelectService;
        this._itmsTransporterPath = null;
        this._itunesConnectApplications = null;
        this._bundleIdentifier = null;
    }
    Object.defineProperty(ITMSTransporterService.prototype, "$projectData", {
        get: function () {
            return this.$injector.resolve("projectData");
        },
        enumerable: true,
        configurable: true
    });
    ITMSTransporterService.prototype.upload = function (data) {
        var _this = this;
        return (function () {
            if (!_this.$hostInfo.isDarwin) {
                _this.$errors.failWithoutHelp("iOS publishing is only available on Mac OS X.");
            }
            temp.track();
            var itmsTransporterPath = _this.getITMSTransporterPath().wait(), ipaFileName = "app.ipa", itmsDirectory = temp.mkdirSync("itms-"), innerDirectory = path.join(itmsDirectory, "mybundle.itmsp"), ipaFileLocation = path.join(innerDirectory, ipaFileName), loggingLevel = data.verboseLogging ? constants_1.ITMSConstants.VerboseLoggingLevels.Verbose : constants_1.ITMSConstants.VerboseLoggingLevels.Informational, bundleId = _this.getBundleIdentifier(data.ipaFilePath).wait(), iOSApplication = _this.getiOSApplication(data.username, data.password, bundleId).wait();
            _this.$fs.createDirectory(innerDirectory).wait();
            _this.$fs.copyFile(data.ipaFilePath, ipaFileLocation).wait();
            var ipaFileHash = _this.$fs.getFileShasum(ipaFileLocation, { algorithm: "md5" }).wait(), ipaFileSize = _this.$fs.getFileSize(ipaFileLocation).wait(), metadata = _this.getITMSMetadataXml(iOSApplication.adamId, ipaFileName, ipaFileHash, ipaFileSize);
            _this.$fs.writeFile(path.join(innerDirectory, constants_1.ITMSConstants.ApplicationMetadataFile), metadata).wait();
            _this.$childProcess.spawnFromEvent(itmsTransporterPath, ["-m", "upload", "-f", itmsDirectory, "-u", helpers_1.quoteString(data.username), "-p", helpers_1.quoteString(data.password), "-v", loggingLevel], "close", { stdio: "inherit" }).wait();
        }).future()();
    };
    ITMSTransporterService.prototype.getiOSApplications = function (credentials) {
        var _this = this;
        return (function () {
            if (!_this._itunesConnectApplications) {
                var requestBody = _this.getContentDeliveryRequestBody(credentials), contentDeliveryResponse = _this.$httpClient.httpRequest({
                    url: "https://contentdelivery.itunes.apple.com/WebObjects/MZLabelService.woa/json/MZITunesProducerService",
                    method: "POST",
                    body: requestBody
                }).wait(), contentDeliveryBody = JSON.parse(contentDeliveryResponse.body);
                if (!contentDeliveryBody.result.Success || !contentDeliveryBody.result.Applications) {
                    var errorMessage = ["Unable to connect to iTunes Connect"];
                    if (contentDeliveryBody.result.Errors && contentDeliveryBody.result.Errors.length) {
                        errorMessage = errorMessage.concat(contentDeliveryBody.result.Errors);
                    }
                    _this.$errors.failWithoutHelp(errorMessage.join(os_1.EOL));
                }
                _this._itunesConnectApplications = contentDeliveryBody.result.Applications.filter(function (app) { return app.type === constants_2.ItunesConnectApplicationTypes.iOS; });
            }
            return _this._itunesConnectApplications;
        }).future()();
    };
    ITMSTransporterService.prototype.getiOSApplication = function (username, password, bundleId) {
        var _this = this;
        return (function () {
            var iOSApplications = _this.getiOSApplications({ username: username, password: password }).wait();
            if (!iOSApplications || !iOSApplications.length) {
                _this.$errors.failWithoutHelp("Cannot find any registered applications for Apple ID " + username + " in iTunes Connect.");
            }
            var iOSApplication = _.find(iOSApplications, function (app) { return app.bundleId === bundleId; });
            if (!iOSApplication) {
                _this.$errors.failWithoutHelp("Cannot find registered applications that match the specified identifier " + bundleId + " in iTunes Connect.");
            }
            return iOSApplication;
        }).future()();
    };
    ITMSTransporterService.prototype.getBundleIdentifier = function (ipaFileFullPath) {
        var _this = this;
        return (function () {
            if (!_this._bundleIdentifier) {
                if (!ipaFileFullPath) {
                    _this._bundleIdentifier = _this.$projectData.projectId;
                }
                else {
                    if (!_this.$fs.exists(ipaFileFullPath).wait() || path.extname(ipaFileFullPath) !== ".ipa") {
                        _this.$errors.failWithoutHelp("Cannot use specified ipa file " + ipaFileFullPath + ". File either does not exist or is not an ipa file.");
                    }
                    _this.$logger.trace("--ipa set - extracting .ipa file to get app's bundle identifier");
                    temp.track();
                    var destinationDir = temp.mkdirSync("ipa-");
                    _this.$fs.unzip(ipaFileFullPath, destinationDir).wait();
                    var payloadDir = path.join(destinationDir, "Payload");
                    var allApps = _this.$fs.readDirectory(payloadDir).wait();
                    _this.$logger.debug("ITMSTransporter .ipa Payload files:");
                    allApps.forEach(function (f) { return _this.$logger.debug(" - " + f); });
                    allApps = allApps.filter(function (f) { return path.extname(f).toLowerCase() === ".app"; });
                    if (allApps.length > 1) {
                        _this.$errors.failWithoutHelp("In the .ipa the ITMSTransporter is uploading there is more than one .app file. We don't know which one to upload.");
                    }
                    else if (allApps.length <= 0) {
                        _this.$errors.failWithoutHelp("In the .ipa the ITMSTransporter is uploading there must be at least one .app file.");
                    }
                    var appFile = path.join(payloadDir, allApps[0]);
                    var plistObject = _this.$bplistParser.parseFile(path.join(appFile, "Info.plist")).wait();
                    var bundleId = plistObject && plistObject[0] && plistObject[0].CFBundleIdentifier;
                    if (!bundleId) {
                        _this.$errors.failWithoutHelp("Unable to determine bundle identifier from " + ipaFileFullPath + ".");
                    }
                    _this.$logger.trace("bundle identifier determined to be " + bundleId);
                    _this._bundleIdentifier = bundleId;
                }
            }
            return _this._bundleIdentifier;
        }).future()();
    };
    ITMSTransporterService.prototype.getITMSTransporterPath = function () {
        var _this = this;
        return (function () {
            if (!_this._itmsTransporterPath) {
                var xcodePath = _this.$xcodeSelectService.getContentsDirectoryPath().wait(), xcodeVersion = _this.$xcodeSelectService.getXcodeVersion().wait(), result = path.join(xcodePath, "Applications", "Application Loader.app", "Contents");
                xcodeVersion.patch = xcodeVersion.patch || "0";
                if (xcodeVersion.major && xcodeVersion.minor &&
                    helpers_1.versionCompare(xcodeVersion, "6.3.0") < 0) {
                    result = path.join(result, "MacOS");
                }
                _this._itmsTransporterPath = path.join(result, constants_1.ITMSConstants.iTMSDirectoryName, "bin", constants_1.ITMSConstants.iTMSExecutableName);
            }
            if (!_this.$fs.exists(_this._itmsTransporterPath).wait()) {
                _this.$errors.failWithoutHelp('iTMS Transporter not found on this machine - make sure your Xcode installation is not damaged.');
            }
            return _this._itmsTransporterPath;
        }).future()();
    };
    ITMSTransporterService.prototype.getContentDeliveryRequestBody = function (credentials) {
        return JSON.stringify({
            id: "1",
            jsonrpc: "2.0",
            method: "lookupSoftwareApplications",
            params: {
                Username: credentials.username,
                Password: credentials.password,
                Version: "2.9.1 (441)",
                Application: "Application Loader",
                OSIdentifier: "Mac OS X 10.8.5 (x86_64)"
            }
        });
    };
    ITMSTransporterService.prototype.getITMSMetadataXml = function (appleId, ipaFileName, ipaFileHash, ipaFileSize) {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<package version=\"software4.7\" xmlns=\"http://apple.com/itunes/importer\">\n    <software_assets apple_id=\"" + appleId + "\">\n        <asset type=\"bundle\">\n            <data_file>\n                <file_name>" + ipaFileName + "</file_name>\n                <checksum type=\"md5\">" + ipaFileHash + "</checksum>\n                <size>" + ipaFileSize + "</size>\n            </data_file>\n        </asset>\n    </software_assets>\n</package>";
    };
    return ITMSTransporterService;
}());
exports.ITMSTransporterService = ITMSTransporterService;
$injector.register("itmsTransporterService", ITMSTransporterService);
