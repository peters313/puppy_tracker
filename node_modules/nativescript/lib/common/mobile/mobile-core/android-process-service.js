"use strict";
var os_1 = require("os");
var device_android_debug_bridge_1 = require("../android/device-android-debug-bridge");
var constants_1 = require("../constants");
var AndroidProcessService = (function () {
    function AndroidProcessService($errors, $staticConfig, $injector, $httpClient) {
        this.$errors = $errors;
        this.$staticConfig = $staticConfig;
        this.$injector = $injector;
        this.$httpClient = $httpClient;
        this._devicesAdbs = {};
    }
    Object.defineProperty(AndroidProcessService.prototype, "androidPortInformationRegExp", {
        get: function () {
            var wordCharacters = "[0-9A-Za-z]+";
            var hexIpAddressWithPort = "[0-9A-Za-z]+:[0-9A-Za-z]+";
            var hexIpAddressWithPortWithSpace = hexIpAddressWithPort + "\\s+";
            var hexIpAddressWithPortWithSpaceMatch = "(" + hexIpAddressWithPort + ")\\s+";
            return new RegExp("(\\d+):\\s+" + hexIpAddressWithPortWithSpaceMatch + hexIpAddressWithPortWithSpaceMatch + wordCharacters + "\\s+" + hexIpAddressWithPortWithSpace + hexIpAddressWithPortWithSpace + wordCharacters + "\\s+(\\d+)", "g");
        },
        enumerable: true,
        configurable: true
    });
    AndroidProcessService.prototype.mapAbstractToTcpPort = function (deviceIdentifier, appIdentifier) {
        var _this = this;
        return (function () {
            var adb = _this.getAdb(deviceIdentifier);
            var processId = _this.getProcessId(adb, appIdentifier).wait();
            var applicationNotStartedErrorMessage = "The application is not started on the device with identifier " + deviceIdentifier + ".";
            if (!processId) {
                _this.$errors.failWithoutHelp(applicationNotStartedErrorMessage);
            }
            var abstractPort = _this.getAbstractPortForApplication(adb, processId, appIdentifier).wait();
            if (!abstractPort) {
                _this.$errors.failWithoutHelp(applicationNotStartedErrorMessage);
            }
            var availablePorts = _this.getAvailableAndroidPortsInformation(adb, appIdentifier).wait();
            if (!availablePorts || !availablePorts.length) {
                _this.$errors.failWithoutHelp("There are no available ports.");
            }
            var realPort = availablePorts[0];
            adb.executeCommand(["forward", ("tcp:" + realPort.number), ("localabstract:" + abstractPort)]).wait();
            return realPort.number;
        }).future()();
    };
    AndroidProcessService.prototype.getDebuggableApps = function (deviceIdentifier) {
        var _this = this;
        return (function () {
            var adb = _this.getAdb(deviceIdentifier);
            var androidWebViewPortInformation = _this.getAbstractPortsInformation(adb).wait().split(os_1.EOL);
            return androidWebViewPortInformation
                .map(function (line) { return _this.getApplicationInfoFromWebViewPortInformation(adb, deviceIdentifier, line).wait(); })
                .filter(function (appIdentifier) { return !!appIdentifier; });
        }).future()();
    };
    AndroidProcessService.prototype.getApplicationInfoFromWebViewPortInformation = function (adb, deviceIdentifier, information) {
        var _this = this;
        return (function () {
            var processIdRegExp = /@webview_devtools_remote_(.+)/g;
            var processIdMatches = processIdRegExp.exec(information);
            var oldAndroidWebViewAppIdentifier;
            if (processIdMatches) {
                var processId = processIdMatches[1];
                var processIdInformation = adb.executeShellCommand(["ps", "|grep", processId]).wait();
                oldAndroidWebViewAppIdentifier = _.last(processIdInformation.trim().split(/[ \t]/));
            }
            var chromeAppIdentifierRegExp = /@(.+)_devtools_remote\s?/g;
            var chromeAppIdentifierMatches = chromeAppIdentifierRegExp.exec(information);
            var chromeAppIdentifier;
            if (chromeAppIdentifierMatches && chromeAppIdentifierMatches.length > 0) {
                chromeAppIdentifier = chromeAppIdentifierMatches[1];
            }
            var cordovaAppIdentifier = oldAndroidWebViewAppIdentifier || chromeAppIdentifier;
            if (cordovaAppIdentifier) {
                return {
                    packageId: cordovaAppIdentifier,
                    framework: constants_1.TARGET_FRAMEWORK_IDENTIFIERS.Cordova,
                    title: _this.getPageTitleFromWebView(adb, deviceIdentifier, cordovaAppIdentifier).wait()
                };
            }
            var nativeScriptAppIdentifierRegExp = /@(.+)-debug/g;
            var nativeScriptAppIdentifierMatches = nativeScriptAppIdentifierRegExp.exec(information);
            if (nativeScriptAppIdentifierMatches && nativeScriptAppIdentifierMatches.length > 0) {
                var appIdentifier = nativeScriptAppIdentifierMatches[1];
                return {
                    packageId: appIdentifier,
                    framework: constants_1.TARGET_FRAMEWORK_IDENTIFIERS.NativeScript,
                    title: "NativeScript Application"
                };
            }
            return null;
        }).future()();
    };
    AndroidProcessService.prototype.getPageTitleFromWebView = function (adb, deviceIdentifier, appIdentifier) {
        var _this = this;
        return (function () {
            var tcpPort = _this.mapAbstractToTcpPort(deviceIdentifier, appIdentifier).wait();
            var response = _this.$httpClient.httpRequest("http://localhost:" + tcpPort + "/json").wait().body;
            adb.executeCommand(["forward", "--remove", ("tcp:" + tcpPort)]).wait();
            if (response) {
                response = JSON.parse(response);
                var responseItem = response[0];
                return responseItem && responseItem.title;
            }
            return null;
        }).future()();
    };
    AndroidProcessService.prototype.getAbstractPortForApplication = function (adb, processId, appIdentifier) {
        var _this = this;
        return (function () {
            var abstractPortsInformation = _this.getAbstractPortsInformation(adb).wait();
            return _this.getPortInformation(abstractPortsInformation, processId) ||
                _this.getPortInformation(abstractPortsInformation, appIdentifier + "_devtools_remote") ||
                _this.getPortInformation(abstractPortsInformation, appIdentifier + "-debug");
        }).future()();
    };
    AndroidProcessService.prototype.getAbstractPortsInformation = function (adb) {
        return adb.executeShellCommand(["cat", "/proc/net/unix"]);
    };
    AndroidProcessService.prototype.getPortInformation = function (abstractPortsInformation, searchedInfo) {
        var processRegExp = new RegExp("\\w+:\\s+(?:\\w+\\s+){1,6}@(.*?" + searchedInfo + ")$", "gm");
        var match = processRegExp.exec(abstractPortsInformation);
        return match && match[1];
    };
    AndroidProcessService.prototype.getProcessId = function (adb, appIdentifier) {
        return (function () {
            var processIdRegExp = /^\w*\s*(\d+)/;
            var processIdInformation = adb.executeShellCommand(["ps", "|grep", appIdentifier]).wait();
            var matches = processIdRegExp.exec(processIdInformation);
            if (!matches || !matches[0]) {
                return null;
            }
            return matches[1];
        }).future()();
    };
    AndroidProcessService.prototype.getAvailableAndroidPortsInformation = function (adb, appIdentifier) {
        var _this = this;
        return (function () {
            var tcpPorts = adb.executeShellCommand(["cat", "proc/net/tcp"]).wait().split(os_1.EOL);
            var tcp6Ports = adb.executeShellCommand(["cat", "proc/net/tcp6"]).wait().split(os_1.EOL);
            var allPorts = tcpPorts.concat(tcp6Ports);
            var emptyAddressRegExp = /^00*/;
            var localHostHexRegExp = /^00*100007F/;
            var localHostVersionSixHexRegExp = /^00*FFFF00000100007F/;
            var availablePorts = _(allPorts)
                .filter(function (line) { return line.match(_this.androidPortInformationRegExp); })
                .map(function (line) { return _this.parseAndroidPortInformation(line); })
                .filter(function (port) {
                return port.remAddress.match(emptyAddressRegExp) &&
                    (port.ipAddressHex.match(localHostHexRegExp) ||
                        port.ipAddressHex.match(localHostVersionSixHexRegExp) ||
                        port.ipAddressHex.match(emptyAddressRegExp));
            })
                .value();
            return availablePorts;
        }).future()();
    };
    AndroidProcessService.prototype.parseAndroidPortInformation = function (portInformationRow) {
        var matches = this.androidPortInformationRegExp.exec(portInformationRow);
        if (!matches || !matches[0]) {
            return null;
        }
        var localAddress = matches[2];
        var localAddressParts = localAddress.split(":");
        var hexIpAddress = localAddressParts[0];
        var hexPort = localAddressParts[1];
        var portInformation = {
            localAddress: localAddress,
            remAddress: matches[3],
            uid: parseInt(matches[4]),
            ipAddressHex: hexIpAddress,
            number: parseInt(hexPort, 16),
            numberHex: hexPort
        };
        return portInformation;
    };
    AndroidProcessService.prototype.getAdb = function (deviceIdentifier) {
        if (!this._devicesAdbs[deviceIdentifier]) {
            this._devicesAdbs[deviceIdentifier] = this.$injector.resolve(device_android_debug_bridge_1.DeviceAndroidDebugBridge, { identifier: deviceIdentifier });
        }
        return this._devicesAdbs[deviceIdentifier];
    };
    return AndroidProcessService;
}());
exports.AndroidProcessService = AndroidProcessService;
$injector.register("androidProcessService", AndroidProcessService);
