"use strict";
var helpers_1 = require("../../common/helpers");
var constants_1 = require("../../constants");
var Future = require("fibers/future");
var FindPluginsCommand = (function () {
    function FindPluginsCommand($pluginsService, $errors, $logger, $prompter, $options, $progressIndicator) {
        this.$pluginsService = $pluginsService;
        this.$errors = $errors;
        this.$logger = $logger;
        this.$prompter = $prompter;
        this.$options = $options;
        this.$progressIndicator = $progressIndicator;
        this.allowedParameters = [];
    }
    FindPluginsCommand.prototype.execute = function (args) {
        var _this = this;
        return (function () {
            var filter = _this.prepareFilter(args);
            var pluginsFuture = _this.$pluginsService.getAvailable(filter);
            if (_this.$options.json) {
                _this.$logger.out(JSON.stringify(pluginsFuture.wait()));
                return;
            }
            _this.$logger.printInfoMessageOnSameLine("Searching npm please be patient...");
            _this.$progressIndicator.showProgressIndicator(pluginsFuture, 500).wait();
            var plugins = pluginsFuture.get();
            _this.showPlugins(plugins).wait();
        }).future()();
    };
    FindPluginsCommand.prototype.canExecute = function (args) {
        return Future.fromResult(true);
    };
    FindPluginsCommand.prototype.showPlugins = function (plugins) {
        var _this = this;
        return (function () {
            var allPluginsNames = _.keys(plugins).sort();
            if (!allPluginsNames || !allPluginsNames.length) {
                _this.$logger.warn("No plugins found.");
                return;
            }
            var count = _this.$options.count || FindPluginsCommand.COUNT_OF_PLUGINS_TO_DISPLAY;
            if (!helpers_1.isInteractive() || _this.$options.all) {
                count = allPluginsNames.length;
            }
            var data = [];
            var pluginsToDisplay = allPluginsNames.splice(0, count);
            var shouldDisplayMorePlugins = true;
            _this.$logger.out("Available NativeScript plugins:");
            do {
                data = _this.createTableCells(plugins, pluginsToDisplay);
                var table = _this.createPluginsTable(data);
                _this.$logger.out(table.toString());
                pluginsToDisplay = allPluginsNames.splice(0, count);
                if (!pluginsToDisplay || pluginsToDisplay.length < 1) {
                    return;
                }
                shouldDisplayMorePlugins = _this.$prompter.confirm("Load more plugins?").wait();
            } while (shouldDisplayMorePlugins);
        }).future()();
    };
    FindPluginsCommand.prototype.createPluginsTable = function (data) {
        var headers = ["Plugin", "Version", "Description"];
        var table = helpers_1.createTable(headers, data);
        return table;
    };
    FindPluginsCommand.prototype.createTableCells = function (plugins, pluginsToDisplay) {
        return pluginsToDisplay.map(function (pluginName) {
            var pluginDetails = plugins[pluginName];
            return [pluginName, pluginDetails.version, pluginDetails.description || ""];
        });
    };
    FindPluginsCommand.prototype.prepareFilter = function (args) {
        return _(args || [])
            .map(function (arg) { return arg.toLowerCase(); })
            .concat(constants_1.NATIVESCRIPT_KEY_NAME)
            .uniq()
            .value();
    };
    FindPluginsCommand.COUNT_OF_PLUGINS_TO_DISPLAY = 10;
    return FindPluginsCommand;
}());
exports.FindPluginsCommand = FindPluginsCommand;
$injector.registerCommand(["plugin|find", "plugin|search"], FindPluginsCommand);
